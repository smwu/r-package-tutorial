[
  {
    "objectID": "tutorial.html",
    "href": "tutorial.html",
    "title": "Building Your Own R Package",
    "section": "",
    "text": "This tutorial provides an introduction to creating, documenting, testing, and releasing an R package with the usethis+devtools workflow. As an example, we begin with a function for normalising UK postcodes, build a basic package around it, and then discuss how to add features to the package. We’ll create the postcoder package, export one function, document it, check it, and publish to GitHub. A CRAN submission checklist is included."
  },
  {
    "objectID": "tutorial.html#introduction",
    "href": "tutorial.html#introduction",
    "title": "Building Your Own R Package",
    "section": "1) Introduction",
    "text": "1) Introduction\n\n1.1 Why build an R package?\nTurning your code into an R package comes with many advantages, including:\n\nKeeping your code in a free, accessible, and easily usable format for future users and projects.\nProviding structured documentation, versioning, and testing of functionality.\nEnabling one-line installation of many functions, through GitHub or CRAN.\n\n\n\n1.2 Getting started\nYou will want to have the following installed on your device before you start building your package from source code.\n\nR (≥ 4.2 recommended)\nRStudio\nR build tools (e.g., Rtools on Windows, Xcode Command Line Tools on macOS). Note: these are required for the below development packages to operate properly. Otherwise, an error will be thrown during installation in the next step.\n\nMore information on installing R, RStudio, and R build tools can be found here: https://ohdsi.github.io/Hades/rSetup.html.\nPlease also install the usethis, devtools, roxygen2, testthat, pkgdown, and remotes packages and then load them by running the following code in RStudio:\n\n\nCode\n# Uncomment below code to install\n# install.packages(c(\"usethis\",\"devtools\",\"roxygen2\",\"testthat\",\"pkgdown\",\"remotes\"))\n\nlibrary(usethis)\nlibrary(devtools)\nlibrary(roxygen2)\nlibrary(testthat)\nlibrary(pkgdown)\nlibrary(remotes)"
  },
  {
    "objectID": "tutorial.html#basic-package-from-existing-r-code",
    "href": "tutorial.html#basic-package-from-existing-r-code",
    "title": "Building Your Own R Package",
    "section": "2) Basic package from existing R code",
    "text": "2) Basic package from existing R code\nFor this tutorial, we’ll be using example R code that converts UK postcodes into standardised formats.\nUK postcodes must be in the following format: 5-7 alphanumeric characters split into two parts, with a single space in the middle and with letters in upper case. The two parts are:\n\nOutward code (specifies area and district): 2-4 characters before the space, starting with a letter. E.g., (“WC1E”, “NW1”, “EH1”, “SP4”)\nInward code (specifies sector and unit): 3 characters after the space, starting with a number. (E.g., “6BT”, “2DB”, “2NG”, “7DE”).\n\nExample postcodes include “WC1E 6BT” (UCL), “NW1 2DB” (British Library), “EH1 2NG” (Edinburgh castle), and “SP4 7DE” (Stonehenge).\nOftentimes, in collected data, postcodes may appear in messy formats that need to be standardised. Here are some examples of issues that may arise and how we would want to handle them.\n\nLetters not in uppercase: “wc1e 6bt” -&gt; “WC1E 6BT”\nNon-alphanumeric characters (e.g., spaces, dashes, punctuation): “.NW12DB” -&gt; “NW1 2DB”\nMissing the single space before the last three characters: “EH12NG” -&gt; “EH1 2NG”\n\nThe following R code converts two mis-formatted postcodes (“wc1e.6bt” and “nw1-2db”) into the acceptable standardised format and also rejects an invalid postcode (“INVALID”). Since this code is vectorised, it can handle multiple postcodes at the same time.\n\n\nCode\n# Example postcodes that need cleaning\nx &lt;- c(\"wc1e.6bt\", \"nw1-2db\", \"INVALID\")\n\n# 1) Conver to uppercase \nx_upper &lt;- toupper(x)\nx_upper\n\n\n[1] \"WC1E.6BT\" \"NW1-2DB\"  \"INVALID\" \n\n\nCode\n# 2) Remove non-alphanumeric and keep only A–Z and 0–9\nx_alphnum &lt;- stringr::str_remove_all(x_upper, \"[^A-Z0-9]\")\nx_alphnum\n\n\n[1] \"WC1E6BT\" \"NW12DB\"  \"INVALID\"\n\n\nCode\n# 3) Ensure a single space before inward code (last 3 chars) \n# Check that postcodes are 5–7 chars (excluding the space).\nn &lt;- nchar(x_alphnum)\nn\n\n\n[1] 7 6 7\n\n\nCode\nwrong_length &lt;- n &lt; 5 | n &gt; 7\nwrong_length\n\n\n[1] FALSE FALSE FALSE\n\n\nCode\nx_reformat &lt;- ifelse(\n  !is.na(x_alphnum) & !wrong_length, # check length and not NA\n  paste0(substr(x_alphnum, 1, n - 3),  # outward code\n         \" \", \n         substr(x_alphnum, n - 2, n)),  # inward code\n  x_alphnum)\nx_reformat\n\n\n[1] \"WC1E 6BT\" \"NW1 2DB\"  \"INVA LID\"\n\n\nCode\n# Regex expression of possible valid alphanumeric orderings for UK postcodes\nstrict_form &lt;- paste0(\n  \"^\",                     # start of string\n  \"(\",                     # start of outward code\n  \"([A-Z][0-9]{1,2})|\",    # letter + 1 or 2 digits\n  \"([A-Z]{2}[0-9]{1,2})|\", # 2 letters + 1 or 2 digits\n  \"([A-Z][0-9][A-Z])|\",    # letter + digit + letter\n  \"([A-Z]{2}[0-9][A-Z]?)\", # 1 letters + digit + optional letter\n  \") \",                    # end of outward code + space\n  \"[0-9][A-Z]{2}\",         # inward code: space + digit + 2 letters\n  \"$\"                      # end of string\n)\nstrict_form\n\n\n[1] \"^(([A-Z][0-9]{1,2})|([A-Z]{2}[0-9]{1,2})|([A-Z][0-9][A-Z])|([A-Z]{2}[0-9][A-Z]?)) [0-9][A-Z]{2}$\"\n\n\nCode\n# Check that the postcode is found inthe regex-specified orderings\nvalid &lt;- grepl(strict_form, x_reformat)\nvalid\n\n\n[1]  TRUE  TRUE FALSE\n\n\nCode\n# Set invalid postcodes to NA_character_\nx_reformat[wrong_length | !valid] &lt;- NA_character_\nx_reformat\n\n\n[1] \"WC1E 6BT\" \"NW1 2DB\"  NA        \n\n\n\n2.1 Turning your code into functions\nThe first step to creating an R package is to turn your code into functions that take in parameters and perform actions. This allows you to easily perform the actions multiple times, while varying the input parameters.\nWe will now convert our postcode formatting code into a single function that takes in a vector of postcodes (x) and returns the re-formatted version of the vector (x_reformat).\nWe’ll also add in a stop function that makes sure the input is a character vector, throwing an error if not.\n\n\nCode\nuk_postcode_reformat &lt;- function(x) {\n\n  # Check input is a character vector\n  if (!is.character(x)) {\n    stop(\"`x` must be character vector; use as.character() first.\")\n  }\n\n  # 1) Conver to uppercase \n  x_upper &lt;- toupper(x)\n  x_upper\n  \n  # 2) Remove non-alphanumeric and keep only A–Z and 0–9\n  x_alphnum &lt;- stringr::str_remove_all(x_upper, \"[^A-Z0-9]\")\n  x_alphnum\n  \n  # 3) Ensure a single space before inward code (last 3 chars) \n  # Check that postcodes are 5–7 chars (excluding the space).\n  n &lt;- nchar(x_alphnum)\n  n\n  wrong_length &lt;- n &lt; 5 | n &gt; 7\n  wrong_length\n  \n  x_reformat &lt;- ifelse(\n    !is.na(x_alphnum) & !wrong_length, # check length and not NA\n    paste0(substr(x_alphnum, 1, n - 3),  # outward code\n           \" \", \n           substr(x_alphnum, n - 2, n)),  # inward code\n    x_alphnum)\n  x_reformat\n  \n  # Regex expression of possible valid alphanumeric orderings for UK postcodes\n  strict_form &lt;- paste0(\n    \"^\",                     # start of string\n    \"(\",                     # start of outward code\n    \"([A-Z][0-9]{1,2})|\",    # letter + 1 or 2 digits\n    \"([A-Z]{2}[0-9]{1,2})|\", # 2 letters + 1 or 2 digits\n    \"([A-Z][0-9][A-Z])|\",    # letter + digit + letter\n    \"([A-Z]{2}[0-9][A-Z]?)\", # 1 letters + digit + optional letter\n    \") \",                    # end of outward code + space\n    \"[0-9][A-Z]{2}\",         # inward code: space + digit + 2 letters\n    \"$\"                      # end of string\n  )\n  strict_form\n  \n  # Check that the postcode is found inthe regex-specified orderings\n  valid &lt;- grepl(strict_form, x_reformat)\n  valid\n  \n  # Set invalid postcodes to NA_character_\n  x_reformat[wrong_length | !valid] &lt;- NA_character_\n  \n  # Return reformatted postcode\n  return(x_reformat)\n}\n\n\nOnce we have the function, we can easily reformat many postcodes.\n\n\nCode\nexample_postcodes &lt;- c(\"wc1e 6bt\", \".NW12DB\", \"EH12NG\", \"SP4 7DE\")\nexample_postcodes\n\n\n[1] \"wc1e 6bt\" \".NW12DB\"  \"EH12NG\"   \"SP4 7DE\" \n\n\nCode\ninvalid_postcodes &lt;- c(\"sw1a1aa1\", \" SW1AA \", \"hiiii\", \"230aaa\", \"INVALID\")\ninvalid_postcodes\n\n\n[1] \"sw1a1aa1\" \" SW1AA \"  \"hiiii\"    \"230aaa\"   \"INVALID\" \n\n\nCode\n# Apply the function to reformat valid postcodes and set invalid ones to NA\nuk_postcode_reformat(x = example_postcodes)\n\n\n[1] \"WC1E 6BT\" \"NW1 2DB\"  \"EH1 2NG\"  \"SP4 7DE\" \n\n\nCode\nuk_postcode_reformat(x = invalid_postcodes)\n\n\n[1] NA NA NA NA NA\n\n\n\n\n2.2 Create the package skeleton\nNow, we’ll convert this function into a package called postcoder. We can use the create_package() function from the usethis package.\n\n\nCode\nusethis::create_package(\"~/Documents/GitHub/postcoder\")\n# Reopen the new project when prompted\n\n\n\nThis creates a new R package project folder named postcoder at the specified path. If prompted, open the new project to ensures RStudio switches its working directory to postcoder/.\n\nOn the bottom right, we can see that the folder contains the basic structure of a valid R package:\npostcoder/\n├─ DESCRIPTION        # Package metadata (name, version, title, authors, etc.)\n├─ NAMESPACE          # Manages which functions are exported/imported (auto-generated by roxygen2) ├─ postcoder.Rproj    # R project for the package\n├─ R/                 # All .R function scripts\nYou may also see .Rbuildignore (things to ignore when building the package) and .gitignore (things to ignore for GitHub).\n\n\n2.3 LICENSE file\nEvery R package must specify a license, so we’ll add a LICENSE file. Here we use the MIT license, which is common for permissive sharing. Other options include use_cc0_license() for public domain release. Replace my name (Stephanie Wu) with your own name as the author of the package.\n\n\nCode\nusethis::use_mit_license(\"Stephanie Wu\")  \n\n\n\n\n\n2.4 DESCRIPTION file\nNext, we’ll fill in DESCRIPTION file that include key metadata. Key components include:\n\nPackage → Automatically added. Package name\nTitle → Short, human-readable title (must be in Title Case)\nVersion → Package version. When choosing a version number, anything that is still in development, will typically look like 0.0.0.9000. Otherwise, fully functional packages ready for release follow a major.minor.patch output (e.g., 1.0.0), where incrementing the patch digit occurs for bug fixes, incrementing the minor digit occurs for new features or functions, and incrementing the major digit occurs if there is a significant restructuring to the package that would break previous code.\nAuthors@R → Structured author information using person(\"First\",\"Last\", role = c(\"aut\",\"cre\"), email = \"you@example.com\"). Possible options for roles include author (“aut”), maintainer (“cre”), contributor (“ctb”), and/or copyright holder (“cph”).\nDescription → A one-sentence summary of what your package does\nLicense → Automatically propagated from use_mit_license().\nDepends → Typically used to specify minimum R version required.\nImports → Packages that are depended on in the functions. Can be added with usethis::use_package(\"stringr\", type = \"Imports\") for the stringr package, for example.\nSuggests → Optional packages, typically used for tests, vignettes, and examples.\nEncoding → Automatically added\nRoxygen: list(markdown = TRUE) → Automatically added. Indicates that Markdown can be used in roxygen documentation notes.\nRoxygenNote: → Automatically added. Roxygen version\n\nYou can edit the file directly in RStudio or Notepad.\nHere’s what your DESCRIPTION file might look like after filling it out.\n\n\nCode\nPackage: postcoder\nTitle: Postcode Cleaning and Formatting Utilities for the UK\nVersion: 0.0.0.9000\nAuthors@R: \n    person(given = \"Stephanie\", family = \"Wu\", \n           email = \"stephanie.wu@ucl.ac.uk\", \n           role = c(\"aut\", \"cre\"),\n           comment = c(ORCID = \"0000-0001-5110-8407\"))\nDescription: Provides a lightweight helper to normalise UK postcodes by \n    uppercasing, removing non-alphanumeric characters, inserting the \n    required single space before the inward code, and validating the \n    format against common UK postcode patterns.\nLicense: MIT + file LICENSE\nEncoding: UTF-8\nDepends:\n    R (&gt;= 3.5.0)\nImports:\n    stringr\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.3\n\n\n\n\n\n2.5 Add the function documentation\nOne of the key aspects of creating an R package is adding roxygen documentation to all of the package functions using specially formatted comments. This is then converted using devtools::document() into proper documentation help files that can be displayed when loading the package.\nAs a reminder, for this package, we have one main function, uk_postcode_reformat() that reformats UK postcodes into a standardised form.\nTo properly document this function for an R package, we need to add the following components:\n\nTitle\nDescription\nInput arguments (using @param)\nOutput values (using @return)\n(Optional) Additional details (using @details)\nUsage examples (using @examples)\n(Optional) Any other packages (other than base) that are used in the function (using @import package_name for the whole package, or @importFrom package_name function_name for specific functions)\n(Optional) @seealso: Linking to other related functions in the package\nExport the function (using @export). Note: it’s possible to write internal functions that you don’t want to be publicly available. To do this, simply don’t add the @export tag.\n\nStart by creating an R file with the same name as your function name within the R/ subfolder in the package. You can do this using RStudio directly or using the use_r() function, shown below.\n\n\nCode\nusethis::use_r(\"uk_postcode_reformat\")\n\n\nNext, past the uk_postcode_reformat() function into this R/uk_postcode_reformat.R file:\n\n\nCode\n#' Reformat UK postcodes\n#'\n#' Cleans UK postcodes according to a strict format by converting to uppercase\n#' and fixing spacing and punctuation.\n#'\n#' @param x A character vector of postcodes.\n#'\n#' @return A character vector `x_reformat` containing the reformatted postcodes.\n#'\n#' @details UK postcodes must be in the following format: 5-7 alphanumeric\n#' characters split into two parts, with a single space in the middle and with\n#' letters in upper case. The two parts are: 1) Outward code (specifies area and\n#' district): 2-4 characters before the space, starting with a letter. E.g.,\n#' (\"WC1E\", \"NW1\", \"EH1\", \"SP4\"); and 2) Inward code (specifies sector and unit):\n#' 3 characters after the space, starting with a number. (E.g., \"6BT\", \"2DB\",\n#' \"2NG\", \"7DE\").\n#'\n#' Example postcodes include \"WC1E 6BT\", \"NW1 2DB\", and \"EH1 2NG\". Oftentimes,\n#' in collected data, postcodes may appear in messy formats that need to be\n#' standardised, such as letters not being in uppercase, the inclusion of\n#' non-alphanumeric characters such as dashes and punctuation, missing the\n#' single space before the last three characters, and non-valid combinations of\n#' characters and letters.\n#'\n#' @importFrom stringr\n#'\n#' @examples\n#' uk_postcode_reformat(c(\"wc1e 6bt\", \".NW12DB\", \"EH12NG\", \"SP4 7DE\"))\n#' uk_postcode_reformat(c(\"sw1a1aa1\", \" SW1AA \", \"hiiii\", \"230aaa\", \"INVALID\"))\n#'\n#' @export\nuk_postcode_reformat &lt;- function(x) {\n\n  # Check input is a character vector\n  if (!is.character(x)) {\n    stop(\"`x` must be character vector; use as.character() first.\")\n  }\n\n  # 1) Conver to uppercase\n  x_upper &lt;- toupper(x)\n  x_upper\n\n  # 2) Remove non-alphanumeric and keep only A–Z and 0–9\n  x_alphnum &lt;- stringr::str_remove_all(x_upper, \"[^A-Z0-9]\")\n  x_alphnum\n\n  # 3) Ensure a single space before inward code (last 3 chars)\n  # Check that postcodes are 5–7 chars (excluding the space).\n  n &lt;- nchar(x_alphnum)\n  n\n  wrong_length &lt;- n &lt; 5 | n &gt; 7\n  wrong_length\n\n  x_reformat &lt;- ifelse(\n    !is.na(x_alphnum) & !wrong_length, # check length and not NA\n    paste0(substr(x_alphnum, 1, n - 3),  # outward code\n           \" \",\n           substr(x_alphnum, n - 2, n)),  # inward code\n    x_alphnum)\n  x_reformat\n\n  # Regex expression of possible valid alphanumeric orderings for UK postcodes\n  strict_form &lt;- paste0(\n    \"^\",                     # start of string\n    \"(\",                     # start of outward code\n    \"([A-Z][0-9]{1,2})|\",    # letter + 1 or 2 digits\n    \"([A-Z]{2}[0-9]{1,2})|\", # 2 letters + 1 or 2 digits\n    \"([A-Z][0-9][A-Z])|\",    # letter + digit + letter\n    \"([A-Z]{2}[0-9][A-Z]?)\", # 1 letters + digit + optional letter\n    \") \",                    # end of outward code + space\n    \"[0-9][A-Z]{2}\",         # inward code: space + digit + 2 letters\n    \"$\"                      # end of string\n  )\n  strict_form\n\n  # Check that the postcode is found inthe regex-specified orderings\n  valid &lt;- grepl(strict_form, x_reformat)\n  valid\n\n  # Set invalid postcodes to NA_character_\n  x_reformat[wrong_length | !valid] &lt;- NA_character_\n\n  # Return reformatted postcode\n  return(x_reformat)\n}\n\n\nRepeat this step for all functions in the package.\nThen, run the following code to automatically generate the Rd documentation file, uk_postcode_reformat.Rd, which will be placed in the man folder. This will also automatically update the NAMESPACE file, which provides a summary of what the package exports and imports.\n\n\nCode\ndevtools::document()\n\n\nThe resulting output creates a uk_postcode_reformat.Rd file within the newly created man folder, which contains all of the generated documentation files. Recall that the raw R functions are stored in the R folder. Below is an example of the generated package documentation using roxygen2 through the devtools::document() function. This file is read only because it is automatically generated.\nYou can also see how the generated NAMESPACE file now includes the exported function. This file is also read only because it is automatically generated.\n\n\n\n2.6 Inspecting the documentation\nWe can check that the function and documentation are working properly by running the load_all() function to load all of the functions in the package. Then, we try out our newly created uk_postcode_reformat function within the package. Lastly, we use ?uk_postcode_reformat to examine the help page for the function, which contains all of the newly created documentation.\n\n\nCode\ndevtools::load_all()\nuk_postcode_reformat(c(\"sw1a1aa\", \" SW1A-1AA \", \"EC1A1BB\"))\n?uk_postcode_reformat\n\n\n\n\n\n2.7 Check & install locally\nTo make sure the package is functioning properly and is suitable for uploading to CRAN, we use the check() function to check for errors, warnings, and notes. To be sure that there are no errors, you can also check the package on the released version of R on windows (check_win_release()), the development version of R on windows (check_win_devel()), and the released version of R on macOS (check_mac_release()).\n\n\nCode\ndevtools::check()\n\n\n \nIf it shows 0 ERRORS, 0 WARNINGS, and 0 NOTES, then your package is now ready to be built. You can build your package using the build() function.\n\n\nCode\ndevtools::build()\n\n\n This will create a .tar.gz file containing your package name and version, which can be installed from source. This means that any computer that has this .tar.gz file will be able to install the package using the install.packages() function, specifying that type = \"source\" and making sure the file location is correct.\n\n\nCode\ninstall.packages(\"/Users/Stephanie/Documents/GitHub/postcoder_0.0.0.9000.tar.gz\", repos = NULL, type = \"source\")\n\n\n\n\n\n2.8 CRAN (and Journal) submission\nTo submit a package to CRAN and make it publicly available, simply upload this .tar.gz file to the CRAN submission form (https://cran.r-project.org/submit.html). You will be prompted to fill in your details and double check all of the information provided in the DESCRIPTION file. The last step is to confirm submission.\n\nThis check list for CRAN submissions is also helpful for checking that your package works on multiple platforms and versions of R: https://cran.r-project.org/web/packages/submission_checklist.html.\nTypically, there will be an automatic review to make sure the package passes all checks without errors, warnings, and notes. Once this happens, there will be a manual review, where you may receive an email requesting changes to your package.\nOnce you have made all the necessary changes, you will get an email confirming that the package is on CRAN, after which anyone will be able to install it with install.packages(postcoder) and use the functions inside.\nYou may also want to publish your package in a journal. Some journal options include:\n\nJournal of Open Source Software: Typically quite fast turnaround\nThe R Journal: The official R journal. For more statistically and computationally novel packages\nJournal of Statistical Software: For more statistically novel packages"
  },
  {
    "objectID": "tutorial.html#addons-vignette-tests-package-data-rcpp-citation",
    "href": "tutorial.html#addons-vignette-tests-package-data-rcpp-citation",
    "title": "Building Your Own R Package",
    "section": "3) Add‑ons: vignette, tests, package data, Rcpp, citation",
    "text": "3) Add‑ons: vignette, tests, package data, Rcpp, citation\nThese upgrades are independent—add them when you need them.\n\n3.1 Tests (with testthat)\nAdding unit tests to your package is a great way to make sure that your functions are running properly. These tests allow you to describe what a function is expected to do, including catching errors, warnings, and messaages. These tests will be run automatically every time you run check(). The testing chapter in the R Packages tutorial provides advice and examples for creating a test suite.\nTo create tests, simply run use_testthat() to create the test folder that contains the testthat/ subfolder for storing the tests, as well as the testthat.R function for set up. This will also add testthat to the “Suggests” field in the DESCRIPTION file.\n\n\nCode\nusethis::use_testthat()\n\n\n\nThen, create a test file for the package function(s) (e.g., uk_postcode_reformat()) using the function use_test(). This will create a file in tests/testthat/ titled test-uk_postcode_reformat.R and initialize it with a toy example.\n\n\nCode\nusethis::use_test(\"uk_postcode_reformat\")\n\n\nYou can now modify this file to include any tests that would be helpful for making sure your function works properly. It’s good practice to try to include some edge cases, including expected errors and NAs. Below is an example of possible tests to add for test-uk_postcode_reformat.R, including checking basic normalisation, already-formatted postcodes, invalid formats, NAs and empty strings, vectorisation of outputs, expected errors, capitalisation, and non-alphanumeric characters.\nTo test that the output of your function matches what you would expect, you can use the following functions that allow you to input the expected output:\n\nexpect_equal(fn_output, expected_output)\nexpect_error(fn_with_input, expected_error_message)\nexpect_true(expected_true_boolean) (e.g., is.na(out[1]))\nexpect_length(fn_output, expected_length)\nexpect_identical(fn_output, expected_matching_output)\n\n\n\nCode\n# tests/testthat/test-postcode.R\n\ntest_that(\"basic normalisation works (case, junk removal, spacing)\", {\n  x &lt;- c(\"wc1e 6bt\", \".NW12DB\", \"EH12NG\", \"SP4 7DE\")\n  out &lt;- uk_postcode_reformat(x)\n  expect_equal(out, c(\"WC1E 6BT\", \"NW1 2DB\", \"EH1 2NG\", \"SP4 7DE\"))\n})\n\ntest_that(\"already-formatted postcodes are unchanged\", {\n  x &lt;- c(\"SW1A 1AA\", \"W1A 0AX\", \"M1 1AE\")\n  out &lt;- uk_postcode_reformat(x)\n  expect_equal(out, x)\n})\n\ntest_that(\"invalid formats become NA (strict format validation)\", {\n  # wrong length after cleaning\n  too_short  &lt;- \"A1A\"          # &lt; 5\n  too_long   &lt;- \"EC1A11BBB\"    # &gt; 7 after cleaning\n  # invalid outward/inward shapes\n  bad_mix    &lt;- \"EC1A1B\"       # inward is only 2 chars after space\n  wrong_ord  &lt;- \"123 ABC\"      # outward must start with a letter\n  weird      &lt;- \"ABCD 123\"     # inward must be digit + 2 letters\n\n  x &lt;- c(too_short, too_long, bad_mix, wrong_ord, weird)\n  out &lt;- uk_postcode_reformat(x)\n  expect_true(all(is.na(out)))\n})\n\ntest_that(\"NA and empty strings are handled\", {\n  x &lt;- c(NA, \"\", \"  \")\n  out &lt;- uk_postcode_reformat(x)\n  expect_true(is.na(out[1]))\n  expect_true(is.na(out[2]))\n  expect_true(is.na(out[3]))\n})\n\ntest_that(\"vectorisation: outputs align with inputs\", {\n  x &lt;- c(\"SE1P0AB\", \"EC1A1BB\", \"BAD\")\n  out &lt;- uk_postcode_reformat(x)\n  expect_length(out, length(x))\n  expect_identical(out[1], \"SE1P 0AB\")\n  expect_identical(out[2], \"EC1A 1BB\")\n  expect_true(is.na(out[3]))\n})\n\ntest_that(\"errors for non-character inputs\", {\n  expect_error(uk_postcode_reformat(123), \"`x` must be character vector\")\n  expect_error(uk_postcode_reformat(list(\"SW1A 1AA\")), \"`x` must be character vector\")\n})\n\ntest_that(\"handles lower/upper/mixed case consistently\", {\n  x &lt;- c(\"sw1a1aa\", \"Sw1A1aA\", \"SW1A1AA\")\n  out &lt;- uk_postcode_reformat(x)\n  expect_equal(unique(out), \"SW1A 1AA\")\n})\n\ntest_that(\"strips non-alphanumeric characters correctly\", {\n  x &lt;- c(\"SE-1P_0AB\", \"E C 1 A - 1 B B\", \"W1A-0AX!\")\n  out &lt;- uk_postcode_reformat(x)\n  expect_equal(out, c(\"SE1P 0AB\", \"EC1A 1BB\", \"W1A 0AX\"))\n})\n\n\nYou can then run the tests by clicking the “Run Tests” button in the top right of the file, or by using the devtools::test() function. Ideally, you should see that all of the tests have passed.\n\n\nCode\ndevtools::test()\n\n\n\nYou can also store built-in datasets in your package to provide examples for functions. These will be put in the data/ folder. It is recommended that each file in this folder is an .rda file created by the save() function, containing an R object with the same name as the file.\nThis can be done with the usethis::use_data() function, inputting in the data that you wish to store. If you would like the data to be overwritten when regenerated, include overwrite = TRUE as an argument. The use_data_raw() function can be used as an alternative if you want to distinguish between raw and cleaned data.\n\n\nCode\n# e.g., 6-row demo of messy and invalid postcodes for the vignette\nexample_data &lt;- data.frame(pc = c(\"wc1e 6bt\", \".NW12DB\", \"EH12NG\",\"hiiii\", \"230aaa\", \"INVALID\"))\nusethis::use_data(example_data, overwrite = TRUE)\n\n\nThis will also prompt you to document your data, following the guidelines at https://r-pkgs.org/data.html.\nTo document our data, we create an example.R file within the R/ folder and add the following information:\n\nTitle\nDescription\nAn overview of the dataset (using @format). This should contain a list describing each variable.\nThe source for the dataset (using @source), often a URL or specified to be via simulation.\nExample usage (using @examples)\nThe name of the dataset in quotations\n\nDatasets should NOT be exported with @export because they are automatically exported using a different process.\n\n\nCode\n#' Demo messy postcode dataset\n#'\n#' A tiny dataset used in examples, vignettes, and tests for the\n#' `postcoder` package.\n#'\n#' @format A data frame with 6 rows and 1 variable:\n#' \\describe{\n#'   \\item{example_data}{Character column of messy UK postcodes}\n#' }\n#' @source Simulated for documentation\n#' @examples\n#' data(example_data)\n#' head(example_data)\n\"example_data\"\n\n\nIn the below output, we can see that the example_data object was created and saved as example_data.rda in the data/ folder. We have also created documentation for the dataset in R/example_data.R.\n\nThen, run devtools::document() to make sure the dataset is documented. You should see “Writing example_data.Rd” as an output. This will also give the dataset a help page that can be accessed with ?example_data.\n\n\n3.2 Vignettes\nMany packages include vignettes to help introduce users to the package. Vignettes are R Markdown documents that are meant to help users know how to use the functions in the package. They will be installed alongside the package and are meant to be fast and reproducible. Heavy chunks of code can be cached to speed up runtime by setting cache = TRUE in the chunk options.\nTo create a vignette, use the usethis::use_vignette() function with the name of the vignette file. Oftentimes, packages will have a main introductory vignette that has the same name as the package, along with potential additional vignettes that explain more complex functionality.\nInitialising a vignette will create the vignettes/ folder containing the specified Rmd file: postcoder.Rmd. By default, it will also add knitr and rmarkdown to the Suggests field in the DESCRIPTION file, as well as specify knitr as the vignette builder engine.\n\n\nCode\nusethis::use_vignette(\"postcoder\")\n\n\nYou can then populate the vignette file with sections such as introduction, installation, function usage, etc.\nNote: in the below file, please replace all instances of === with ``` when creating the actual vignette .Rmd file.\n\n\n\nCode\n---\ntitle: \"Getting started with postcoder\"\ndate: \"`r format(Sys.Date())`\"\noutput: \n  rmarkdown::html_vignette:\n    number_sections: true\n    toc: true\n    df_print: \"paged\"\nvignette: &gt;\n  %\\VignetteIndexEntry{postcoder}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n# Introduction \n\nThe `postcoder` package provides functions to convert UK postcodes into standardised formats. \n\nUK postcodes must be in the following format: 5-7 alphanumeric characters split into two parts, with a single space in the middle and with letters in upper case. The two parts are: - *Outward code* (specifies area and district): 2-4 characters before the space, starting with a letter. E.g., (\"WC1E\", \"NW1\", \"EH1\", \"SP4\") - *Inward code* (specifies sector and unit): 3 characters after the space, starting with a number. (E.g., \"6BT\", \"2DB\", \"2NG\", \"7DE\").\n\nExample postcodes include \"WC1E 6BT\", \"NW1 2DB\", and \"EH1 2NG\". Oftentimes,\nin collected data, postcodes may appear in messy formats that need to be\nstandardised, such as letters not being in uppercase, the inclusion of\nnon-alphanumeric characters such as dashes and punctuation, missing the\nsingle space before the last three characters, and non-valid combinations of\ncharacters and letters.\n\n`postcoder` contains one main function, `uk_postcode_reformat()`, which cleans postcodes by applying the following reformatting steps:\n\n1. Convert to uppercase\n2. Remove non-alphanumeric characteris\n3. Insert a single space before the inward code (last 3 characters)\n4. Validate the format, with invalid inputs becoming `NA_character`.\n\nThe vignette shows installation and basic usage.\n\n# Installation\n\nThe package can be installed using the options below.\n\n==={r vig_isntall, eval = FALSE}\n# From CRAN\ninstall.packages(\"postcoder\")\n\n# From Github\nremotes::install_github(\"smwu/postcoder\")\n\n# From source\ninstall.packages(\"~/postcoder_0.0.0.9000.tar.gz\", repos = NULL, type = \"source\")\n===\n\n==={r vig_load, echo = FALSE}\n# Loading the package under the hood for the vignette\ndevtools::load_all()\n===\n\n==={r vig_setup}\nlibrary(postcoder)\n===\n\n# Example functionality\n\nThe `uk_postcode_reformat()` function takes in a character vector of UK postcodes that need to be reformatted. It returns a character vector containing the reformatted postcodes, with invalid postcodes set to `NA_character`.\n\n==={r vig_usage}\n# Load in the example package data\ndata(example_data)\n\n# View the data\nexample_data\n\n# Convert to character vector\ninput &lt;- as.character(example_data$pc)\ninput\n\n# Clean the postcodes\nuk_postcode_reformat(input)\n===\n\nWe obtained the following transformations of the input postcodes:\n\n- \"wc1e 6bt\" -&gt; \"WC1E 6BT\" (capitalised)\n- \".NW12DB\" -&gt; \"NW1 2DB\" (punctuation removed and space added)\n- \"EH12ND\" -&gt; \"EH1 2ND\" (space added)\n- \"hiiii\" -&gt; NA (invalid format)\n- \"230aaa\" -&gt; NA (invalid sequence of numbers and letters)\n- \"INVALID\" -&gt; NA (invalid format)\n\n\nClick on Knit to render the vignette into a vignette document.\n\nIt is recommended to also re-run devtools::check() to make sure your package still works.\n\n\n3.3 Citation file\n\n\nCode\nusethis::use_citation()\n\n\nCreates a template inst/CITATION file. Add in the citation information into the file and save changes.\n\n\nCode\ncitHeader(\"To cite the postcoder R package in publications, please use:\")\n\nbibentry(\n  bibtype  = \"Manual\",\n  title    = \"postcoder: Postcode Cleaning and Formatting Utilities for the UK\",\n  author   = person(given = \"Stephanie\", family = \"Wu\",\n                    email = \"stephanie.wu@ucl.ac.uk\",\n                    role = c(\"aut\", \"cre\")),\n  year     = \"2025\",\n  note     = \"R package version 0.0.0.9000\",\n  url      = \"https://github.com/smwu/postcoder\",\n  textVersion = paste(\n    \"Wu, S. (2025). postcoder: Postcode Cleaning and Formatting Utilities for the UK\",\n    \"(R package version 0.1.0). Available at https://github.com/smwu/postcoder\"\n  )\n)\n\n\nYou can then check the citation output.\n\n\nCode\ncitation(\"postcoder\")\n\n\n\n\n\n3.4 Version control with GitHub\nYou can also initialise version control with Git and GitHub so you can track changes and store them in a remote repository. Use usethis::use_git() to initialise a local Git repository for your project, and usethis::use_github() to connect the local repository to a new remote repository on GitHub, performing an initial push. Agree to adding commits and to restarting RStudio.\n\n\nCode\nusethis::use_git()\nusethis::use_github()\n\n\nNote: you’ll need to have Git and GitHub configured locally. Click on the call out box for more information.\n\n\n\n\n\n\nNoteClick here for instructions for setting up Git and GitHub.\n\n\n\n\n\nHow to set up GitHub:\n1. Create a GitHub account: https://github.com/signup.\n2. Download GitHub Desktop: https://desktop.github.com/download/.\n3. Open GitHub Desktop and link your account. More detailed instructions can be found here: https://docs.github.com/en/desktop/overview/getting-started-with-github-desktop.\n4. Now you can clone the repository. In GitHub Desktop, go to File -&gt; Clone Repository. Click on the “URL” tab.\n5. Navigate back to this repository and click on the green “&lt;&gt; Code” button in the top right corner. Click on the “HTTPS” tab and copy the web URL.\n6. Paste the URL into GitHub Desktop. Under “Local Path”, you can choose where you want the cloned repository to be stored on your local computer.\n7. Click “Clone”.\n8. Now, you can make edits to the repository locally and the changes will be displayed in GitHub Desktop. Once you’ve reviewed your changes, you can write a commit message and commit your changes by clicking on the blue “Commit” button. More detailed instructions on committing your changes can be found here: https://docs.github.com/en/desktop/making-changes-in-a-branch/committing-and-reviewing-changes-to-your-project-in-github-desktop.\n9. You can then push your changes to the remote repository. You will first want to pull in any updates that have occurred in the repo by clicking on the “Fetch origin” button in the top right corner. by clicking on “Push origin” in the top right corner.\nIf you want to experiment with code changes and isolate your development work from the main branch in the repository, you can also create a separate branch. More information can be found here: https://docs.github.com/en/desktop/making-changes-in-a-branch/managing-branches-in-github-desktop."
  },
  {
    "objectID": "tutorial.html#conclusion",
    "href": "tutorial.html#conclusion",
    "title": "Building Your Own R Package",
    "section": "4) Conclusion",
    "text": "4) Conclusion\nYou now have a repeatable workflow to take a function from a script to a shareable, documented, and tested R package!\nStart simple, keep examples fast, and add features (tests, data, CI, website, CRAN) as your needs grow. Small, well‑scoped packages are easier to maintain and much easier for collaborators to use.\n\n4.1 Summary of final Workflow\nHere is a summary of the final workflow\n\nCreate package skeleton usethis::create_package(\"~/postcoder)\nFill in the DESCRIPTION & LICENSE (usethis::use_mit_license(\"Stephanie Wu\"))\nAdd uk_postcode_reformat() function and add roxygen documentation comments to export the function (e.g., @export)\nRun devtools::document() to generate documentation. Then inspect with devtools::load_all() and ?uk_postcode_reformat.\nAdd tests with usethis::use_testthat() and usethis::use_test(\"uk_postcode_reformat\"). Check them with devtools::test().\nAdd a vignette with usethis::use_vignette(\"postcoder\").\nCheck for errors, warnings, and notes with devtools::check()\nAdd a citation with usethis::use_citation()\nConnect to GitHub with usethis::use_git() and usethis::use_github()\nBuild the package with devtools::build() and submit to CRAN: https://cran.r-project.org/submit.html and/or a software journal.\n\n\n\n4.2 Resources\nHere are some additional resources that may be helpful:\n\nR Packages (2e): Wickham & Bryan:https://r-pkgs.org\nusethis:https://usethis.r-lib.org\ndevtools:https://devtools.r-lib.org\nroxygen2:https://roxygen2.r-lib.org\ntestthat:https://testthat.r-lib.org\npkgdown:https://pkgdown.r-lib.org\nWriting R Extensions(CRAN manual):https://cran.r-project.org/doc/manuals/r-release/R-exts.html\nCRAN Repository Policy:https://cran.r-project.org/web/packages/policies.html\nGitHub Actions for R:https://github.com/r-lib/actions\nQuarto documentation:https://quarto.org"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "MIT License",
    "section": "",
    "text": "MIT License\nCopyright (c) 2025 Stephanie Wu\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  }
]